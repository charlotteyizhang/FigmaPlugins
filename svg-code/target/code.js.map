{
  "version": 3,
  "sources": ["../src/code.ts"],
  "sourcesContent": ["// This plugin will open a window to prompt the user to enter a number, and\n// it will then create that many rectangles on the screen.\n\nimport {\n  findOrCreateCollection,\n  generateErrorTemplateFn,\n  generateTemplateFn,\n  modeName,\n} from \"./helper\";\n\n// This file holds the main code for plugins. Code in this file has access to\n// the *figma document* via the figma global object.\n// You can access browser APIs in the <script> tag inside \"ui.html\" which has a\n// full browser environment (See https://www.figma.com/plugin-docs/how-plugins-run).\n\n// This shows the HTML page in \"ui.html\".\nfigma.showUI(__html__, { width: 500, height: 600 });\n\n// Calls to \"parent.postMessage\" from within the HTML page will trigger this\n// callback. The callback will be passed the \"pluginMessage\" property of the\n// posted message.\n\ninterface Create {\n  type: \"convert\";\n}\n\ntype Message = Create;\nfigma.ui.onmessage = async (msg: Message) => {\n  // One way of distinguishing between different types of messages sent from\n  // your HTML page is to use an object with a \"type\" property like this.\n  if (msg.type === \"convert\") {\n    const list: Record<string, string> = {};\n    const promises = figma.currentPage.selection.map(async (node) => {\n      await mutateList(node, list);\n    });\n    Promise.all(promises).then(() => {\n      console.log({ done: list });\n\n      const str = Object.entries(list)\n        .map(([name, value]) => {\n          const names = name.split(\"/\");\n          return `${value}={${\n            names[0].charAt(0).toLowerCase() + names[0].slice(1)\n          }${names[1].charAt(0).toUpperCase() + names[1].slice(1)}[theme].${\n            names[2]\n          }}`;\n        })\n        .join(\",\");\n\n      console.log({ str });\n\n      if (str !== undefined) {\n        figma.ui.postMessage(str);\n      }\n    });\n  }\n};\n\nconst get = async (\n  v: VariableAlias,\n  list: Record<string, string>\n): Promise<{ color: string; name: string } | undefined> => {\n  const varId = v.id;\n  const variable = await figma.variables.getVariableByIdAsync(varId);\n  if (variable === null) {\n    return undefined;\n  } else {\n    const variableName = variable.name;\n    const variableValue = Object.values(variable.valuesByMode).map((v) => v);\n\n    if (\n      variableName !== undefined &&\n      list[variableName] === undefined &&\n      variableValue !== undefined\n    ) {\n      return {\n        color: rgbaToHex(variableValue[0] as RGBA),\n        name: variableName,\n      };\n    }\n    return undefined;\n  }\n};\n\nconst mutateList = async (node: SceneNode, list: Record<string, string>) => {\n  // recurse children\n  if (\"children\" in node) {\n    await Promise.all(node.children.map((child) => mutateList(child, list)));\n    return undefined;\n  } else {\n    if (\"fills\" in node && node.boundVariables?.fills) {\n      // console.log({ fills: node.boundVariables.fills });\n\n      const promises = node.boundVariables.fills.map(async (v) => {\n        const result = await get(v, list);\n        if (result !== undefined && list[result.name] === undefined) {\n          list[result.name] = result.color;\n        }\n        console.log({ list });\n      });\n      await Promise.all(promises);\n      return undefined;\n    }\n  }\n};\nconst rgbaToHex = (v: RGBA): string => {\n  // Clamp values between 0\u2013255 for RGB\n  const R = Math.round(v.r * 255);\n  const G = Math.round(v.g * 255);\n  const B = Math.round(v.b * 255);\n\n  // Clamp alpha between 0\u2013255\n  const A = Math.round(v.a * 255);\n\n  // Convert each to 2-digit hex\n  const hex = (n: number) => n.toString(16).padStart(2, \"0\").toUpperCase();\n\n  // If alpha = 255 (fully opaque), return #RRGGBB\n  if (A === 255) {\n    return `#${hex(R)}${hex(G)}${hex(B)}`;\n  }\n\n  // Otherwise return #RRGGBBAA\n  return `#${hex(R)}${hex(G)}${hex(B)}${hex(A)}`;\n};\n"],
  "mappings": "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",
  "names": ["v"]
}
