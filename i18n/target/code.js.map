{
  "version": 3,
  "sources": ["../src/helper.ts", "../src/code.ts"],
  "sourcesContent": ["export const findOrCreateCollection = (\n  localCollections: Array<VariableCollection>,\n  targetName: string\n) => {\n  const collection = localCollections.find((v) => {\n    return v.name.match(targetName);\n  });\n  if (collection === undefined) {\n    return figma.variables.createVariableCollection(targetName);\n  } else {\n    return collection;\n  }\n};\n\nexport const modeName = {\n  en: \"en\",\n  ja: \"ja\",\n} as const;\nexport type Mode = keyof typeof modeName;\n\nconst patterns = [\n  {\n    paramName: \"number+unit\",\n    displayVariableName: \"unit\",\n    p: /(?:\\b\\d+(?:\\.\\d+)?\\s?(?:w|wh|kwh|kw)\\b|\\d+(?:\\.\\d+)?%)/i,\n  }, // number + unit\n  {\n    paramName: \"timestamp\",\n    displayVariableName: \"timestamp\",\n    p: /\\b\\d{1,2}:\\d{2}(?:\\s?(?:AM|PM))?\\b/i,\n  }, // timestamp (12, 4:30, 3 AM)\n];\nexport const getParamMatchingPattern = (input: string) => {\n  const regex = /\\[\\[(.*?)\\]\\]/g;\n  return [...input.matchAll(regex)].map((m) => m[1]);\n};\nexport const generateTemplateFn = (input: string): string => {\n  let matchStr = input;\n\n  const specialInputs = getParamMatchingPattern(input);\n\n  const params: Array<string> = [];\n  let idx = 0;\n\n  for (const specialInput of specialInputs) {\n    for (const pattern of patterns) {\n      const match = specialInput.match(pattern.p);\n\n      if (match) {\n        const displayName = pattern.displayVariableName + idx;\n        const replaced = matchStr.replace(\n          \"[[\" + specialInput + \"]]\",\n          \"${\" + displayName + \"}\"\n        );\n        params.push(displayName + \":string\");\n        matchStr = replaced;\n      }\n    }\n  }\n\n  return matchStr !== input\n    ? \"(\" + params.join(\",\") + \")=>\" + \"`\" + matchStr + \"`\"\n    : `\"${input}\"`;\n};\n\nexport const generateErrorTemplateFn = (input: string): string => {\n  let matchStr = input;\n\n  const params: Array<string> = [];\n  const displayName = \"statusCode\";\n\n  const match = input.match(/\\b\\d+(\\.\\d+)?\\b/);\n  console.log({ match });\n\n  if (match) {\n    const replaced = input.replace(match[0], \"${\" + displayName + \"}\");\n    params.push(displayName + \":number\");\n    matchStr = replaced;\n  }\n\n  return matchStr !== input\n    ? \"(\" + params.join(\",\") + \")=>\" + \"`\" + matchStr + \"`\"\n    : `\"${input}\"`;\n};\n", "// This plugin will open a window to prompt the user to enter a number, and\n// it will then create that many rectangles on the screen.\n\nimport {\n  findOrCreateCollection,\n  generateErrorTemplateFn,\n  generateTemplateFn,\n  getParamMatchingPattern,\n  modeName,\n} from \"./helper\";\n\n// This file holds the main code for plugins. Code in this file has access to\n// the *figma document* via the figma global object.\n// You can access browser APIs in the <script> tag inside \"ui.html\" which has a\n// full browser environment (See https://www.figma.com/plugin-docs/how-plugins-run).\n\n// This shows the HTML page in \"ui.html\".\nfigma.showUI(__html__, { width: 500, height: 600 });\n\n// Calls to \"parent.postMessage\" from within the HTML page will trigger this\n// callback. The callback will be passed the \"pluginMessage\" property of the\n// posted message.\n\ninterface Generate {\n  type: \"generateTranslationVariables\";\n}\ninterface Rename {\n  type: \"renameLayersToVariableName\";\n}\ninterface Create {\n  type: \"createVariables\";\n  language: \"en\" | \"ja\";\n}\ninterface CreateCode {\n  type: \"createCode\";\n}\n\ntype Message = Generate | Rename | Create | CreateCode;\nfigma.ui.onmessage = async (msg: Message) => {\n  // One way of distinguishing between different types of messages sent from\n  // your HTML page is to use an object with a \"type\" property like this.\n  if (msg.type === \"generateTranslationVariables\") {\n    let str = \"\";\n    const localCollections =\n      await figma.variables.getLocalVariableCollectionsAsync();\n\n    const i18nCollection = localCollections.find((c) => c.name === \"i18n\");\n    console.log({ i18nCollection });\n\n    if (i18nCollection === undefined) {\n      return figma.ui.postMessage(\"No i18nCollection found.\");\n    } else {\n      const modes = i18nCollection?.modes;\n      for (let i = 0; i < modes.length; i++) {\n        const modeName = modes[i].name;\n        str += `const i18n_${modeName} = {`;\n\n        for (const translationKey of i18nCollection.variableIds) {\n          const variable = await figma.variables.getVariableByIdAsync(\n            translationKey\n          );\n          if (variable === null) {\n            console.warn(`Variable with id ${translationKey} not found.`);\n            return;\n          } else {\n            const name = variable.name.replace(/\\//g, \"_\");\n\n            const value =\n              variable.valuesByMode[modes[i].modeId] ?? \"i18n.TODO_TRANSLATE\";\n\n            if (variable.name.includes(\"error\")) {\n              str += `\"${name}\": ${generateErrorTemplateFn(value.toString())},`;\n            } else {\n              str += `\"${name}\": ${generateTemplateFn(value.toString())},`;\n            }\n          }\n        }\n\n        str += \"};\\n\";\n      }\n    }\n\n    figma.ui.postMessage(str);\n  } else if (msg.type === \"renameLayersToVariableName\") {\n    const localCollections =\n      await figma.variables.getLocalVariableCollectionsAsync();\n\n    const i18nCollection = localCollections.find((c) => c.name === \"i18n\");\n    console.log({ i18nCollection });\n\n    if (i18nCollection === undefined) {\n      return figma.ui.postMessage(\"No i18nCollection found.\");\n    } else {\n      for (const node of figma.currentPage.selection) {\n        if (node.type === \"TEXT\") {\n          const boundVariableCharacter = node.boundVariables?.characters;\n\n          if (boundVariableCharacter !== undefined) {\n            const variable = await figma.variables.getVariableByIdAsync(\n              boundVariableCharacter.id\n            );\n            if (variable !== null) {\n              const variableName = `#${variable.name}`;\n              node.name = variableName;\n              figma.ui.postMessage(\n                `successfully renamed layer to ${variableName} `\n              );\n            } else {\n              figma.ui.postMessage(\n                `bound variable not found for layer ${node.name}, skipping rename`\n              );\n            }\n          } else {\n            const inferredVariables = node.inferredVariables?.characters;\n            const variableId =\n              inferredVariables !== undefined && inferredVariables.length > 0\n                ? (await figma.variables.getVariableByIdAsync(\n                    inferredVariables[0].id\n                  )) ?? undefined\n                : undefined;\n            if (variableId !== undefined) {\n              const variableName = `#${variableId.name}`;\n              node.name = variableName;\n              figma.ui.postMessage(\n                `successfully renamed layer to ${variableName} `\n              );\n            } else {\n              figma.ui.postMessage(\n                `no variable found for layer ${node.name}, skipping rename`\n              );\n            }\n          }\n        }\n      }\n    }\n  } else if (msg.type === \"createVariables\") {\n    const targetName = \"i18n\";\n    const localCollections =\n      await figma.variables.getLocalVariableCollectionsAsync();\n\n    const i18nCollection = findOrCreateCollection(localCollections, targetName);\n    // creating a collection will have 1 default mode therefore we are checking this\n    if (i18nCollection.modes.length === 1) {\n      i18nCollection.renameMode(i18nCollection.modes[0].modeId, modeName.en);\n      i18nCollection.addMode(modeName.ja);\n    }\n\n    const targetModeId =\n      msg.language === \"en\"\n        ? i18nCollection.modes[0].modeId\n        : i18nCollection.modes[1].modeId;\n\n    for (const node of figma.currentPage.selection) {\n      if (node.type === \"TEXT\" && node.visible && node.name.startsWith(\"#\")) {\n        const layerName = node.name.substring(1); // Remove the leading '#'\n        const nodeText = node.characters;\n\n        let variable: Variable | undefined = undefined;\n\n        for (const variableId of i18nCollection.variableIds) {\n          const v = await figma.variables.getVariableByIdAsync(variableId);\n          if (v?.name === layerName) {\n            variable = v;\n            break;\n          }\n        }\n\n        if (variable === undefined) {\n          variable = await figma.variables.createVariable(\n            layerName,\n            i18nCollection,\n            \"STRING\"\n          );\n          if (variable !== undefined) {\n            console.log({ node: nodeText });\n\n            variable.setValueForMode(targetModeId, nodeText);\n            const specialInputs = getParamMatchingPattern(nodeText);\n\n            const paramStr = specialInputs.reduce(\n              (acc, s) => acc + \"[[\" + s + \"]]\",\n              \"\"\n            );\n\n            variable.setValueForMode(\n              i18nCollection.modes[1].modeId,\n              paramStr + \"TODO_TRANSLATE\"\n            );\n            node.setBoundVariable(\"characters\", variable);\n            figma.ui.postMessage(\"successfully created translation variables\");\n          } else {\n            figma.ui.postMessage(\n              `error generate variable layer name: ${layerName}`\n            );\n          }\n        } else {\n          const variableValue = variable.valuesByMode[targetModeId];\n\n          if (variableValue !== undefined && nodeText !== variableValue) {\n            variable.setValueForMode(targetModeId, nodeText);\n            node.setBoundVariable(\"characters\", variable);\n            figma.ui.postMessage(\n              `layer name already exists in i18n collection, replaced ${variableValue} with ${nodeText}`\n            );\n          } else {\n            node.setBoundVariable(\"characters\", variable);\n            figma.ui.postMessage(\n              `layer name already exists in i18n collection, associated to: ${layerName}`\n            );\n          }\n        }\n      }\n    }\n  } else if (msg.type === \"createCode\") {\n    let str = \"\";\n    for (const node of figma.currentPage.selection) {\n      if (node.type === \"TEXT\") {\n        const layerName = node.name.substring(1).replace(/\\//g, \"_\"); // Remove the leading '#' and translate to code\n\n        str += `translationsCommon[userLocale.userLanguage].${layerName}`;\n      }\n    }\n\n    figma.ui.postMessage(str);\n  }\n};\n"],
  "mappings": "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",
  "names": ["modeName"]
}
